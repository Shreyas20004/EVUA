"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
var _fp = require("lodash/fp");
var _traverser = _interopRequireDefault(require("../../traverser"));
var _PotentialClass = _interopRequireDefault(require("./PotentialClass"));
var _PotentialMethod = _interopRequireDefault(require("./PotentialMethod"));
var _PotentialConstructor = _interopRequireDefault(require("./PotentialConstructor"));
var _matchFunctionDeclaration = _interopRequireDefault(require("./matchFunctionDeclaration"));
var _matchFunctionVar = _interopRequireDefault(require("./matchFunctionVar"));
var _matchFunctionAssignment = _interopRequireDefault(require("./matchFunctionAssignment"));
var _matchPrototypeFunctionAssignment = _interopRequireDefault(require("./matchPrototypeFunctionAssignment"));
var _matchPrototypeObjectAssignment = _interopRequireDefault(require("./matchPrototypeObjectAssignment"));
var _matchObjectDefinePropertyCall = _interopRequireWildcard(require("./matchObjectDefinePropertyCall"));
var _Inheritance = _interopRequireDefault(require("./inheritance/Inheritance"));
var _matchObjectDefinePropertiesCall = _interopRequireWildcard(require("./matchObjectDefinePropertiesCall.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _default(ast, logger) {
  var potentialClasses = {};
  var inheritance = new _Inheritance["default"]();
  _traverser["default"].traverse(ast, {
    enter: function enter(node, parent) {
      var m;
      if (m = (0, _matchFunctionDeclaration["default"])(node) || (0, _matchFunctionVar["default"])(node)) {
        potentialClasses[m.className] = new _PotentialClass["default"]({
          name: m.className,
          fullNode: node,
          commentNodes: [node],
          parent: parent
        });
        potentialClasses[m.className].setConstructor(new _PotentialConstructor["default"]({
          methodNode: m.constructorNode,
          potentialClass: potentialClasses[m.className]
        }));
      } else if (m = (0, _matchFunctionAssignment["default"])(node)) {
        if (potentialClasses[m.className]) {
          potentialClasses[m.className].addMethod(new _PotentialMethod["default"]({
            name: m.methodName,
            methodNode: m.methodNode,
            fullNode: node,
            commentNodes: [node],
            parent: parent,
            "static": true
          }));
        }
      } else if (m = (0, _matchPrototypeFunctionAssignment["default"])(node)) {
        if (potentialClasses[m.className]) {
          potentialClasses[m.className].addMethod(new _PotentialMethod["default"]({
            name: m.methodName,
            methodNode: m.methodNode,
            fullNode: node,
            commentNodes: [node],
            parent: parent
          }));
        }
      } else if (m = (0, _matchPrototypeObjectAssignment["default"])(node)) {
        if (potentialClasses[m.className]) {
          m.methods.forEach(function (method, i) {
            var assignmentComments = i === 0 ? [node] : [];
            potentialClasses[m.className].addMethod(new _PotentialMethod["default"]({
              name: method.methodName,
              methodNode: method.methodNode,
              fullNode: node,
              commentNodes: assignmentComments.concat([method.propertyNode]),
              parent: parent,
              kind: classMethodKind(method.kind)
            }));
          });
        }
      } else if (m = (0, _matchObjectDefinePropertyCall["default"])(node)) {
        if (potentialClasses[m.className]) {
          m.descriptors.forEach(function (desc, i) {
            var parentComments = i === 0 ? [node] : [];
            potentialClasses[m.className].addMethod(new _PotentialMethod["default"]({
              name: m.methodName,
              methodNode: desc.methodNode,
              fullNode: node,
              commentNodes: parentComments.concat([desc.propertyNode]),
              parent: parent,
              kind: desc.kind,
              "static": m["static"]
            }));
          });
        }
      } else if (m = (0, _matchObjectDefinePropertiesCall["default"])(node)) {
        // defineProperties allows mixing method definitions we CAN transform
        // with ones we CANT. This check looks for whether every property is
        // one we CAN transform and if they are it removes the whole call
        // to defineProperties
        var removeWholeNode = false;
        if (node.expression.arguments[1].properties.every(function (propertyNode) {
          var _matchDefinedProperti = (0, _matchObjectDefinePropertiesCall.matchDefinedProperties)(propertyNode),
            properties = _matchDefinedProperti.properties;
          return properties.some(_matchObjectDefinePropertyCall.isAccessorDescriptor);
        })) {
          removeWholeNode = true;
        }
        m.forEach(function (method, i) {
          if (potentialClasses[method.className]) {
            method.descriptors.forEach(function (desc, j) {
              var parentComments = j === 0 ? [method.methodNode] : [];

              // by default remove only the single method property of the object passed to defineProperties
              // otherwise if they should all be remove AND this is the last descriptor set it up
              // to remove the whole node that's calling defineProperties
              var lastDescriptor = i === m.length - 1 && j === method.descriptors.length - 1;
              var fullNode = lastDescriptor && removeWholeNode ? node : method.methodNode;
              var parentNode = lastDescriptor && removeWholeNode ? parent : node.expression.arguments[1];
              potentialClasses[method.className].addMethod(new _PotentialMethod["default"]({
                name: method.methodName,
                methodNode: desc.methodNode,
                fullNode: fullNode,
                commentNodes: parentComments.concat([desc.propertyNode]),
                parent: parentNode,
                kind: desc.kind,
                "static": method["static"]
              }));
            });
          }
        });
      } else if (m = inheritance.process(node, parent)) {
        if (potentialClasses[m.className]) {
          potentialClasses[m.className].setSuperClass(m.superClass, m.relatedExpressions);
        }
      }
    },
    leave: function leave(node) {
      if (node.type === 'Program') {
        (0, _fp.values)(potentialClasses).filter(function (cls) {
          return cls.isTransformable() ? true : logWarning(cls);
        }).forEach(function (cls) {
          return cls.transform();
        });
      }
    }
  });

  // Ordinary methods inside class use kind=method,
  // unlike methods inside object literal, which use kind=init.
  function classMethodKind(kind) {
    return kind === 'init' ? 'method' : kind;
  }
  function logWarning(cls) {
    if (/^[A-Z]/.test(cls.getName())) {
      logger.warn(cls.getFullNode(), "Function ".concat(cls.getName(), " looks like class, but has no prototype"), 'class');
    }
  }
}